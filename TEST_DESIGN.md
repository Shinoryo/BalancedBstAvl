# AVL Tree テストケース設計書

## 用語

- **再バランス**: AVL 条件（部分木の高さ差が許容範囲を超える）が崩れた際に行う調整操作（回転を含む）。
- **後継**: 削除操作で用いる `in-order successor`（削除対象の右部分木で最小のノード）。

## 1. `__init__` (コンストラクタ)

| No. | テスト観点 | 検証内容 | 前提条件 | テスト手順 | 期待結果 |
| --- | --- | --- | --- | --- | --- |
| 1-1 | `key` の指定 | なし | - | `AVLTree()` | 内部属性が `_key=None`, `_value=None`, `_h=0`, `_l=None`, `_r=None` である |
| 1-2 | `key` の指定 | あり | - | `AVLTree(10)` | 内部属性が `_key=10`, `_value=None`, `_h=1` である |
| 2-1 | `value`の指定 | なし | - | - | NN（1-2で検証済み） |
| 2-2 | `value`の指定 | あり | - | `AVLTree(5, "val")` | 内部属性が `_key=5`, `_value="val"`, `_h=1` である |

## 2. `set(x: int, value: Any) → AVLTree`

| No. | テスト観点 | 検証内容 | 前提条件 | テスト手順 | 期待結果 |
| --- | --- | --- | --- | --- | --- |
| 1-1 | ルートへの操作 | 空の木 | `t = AVLTree()` | `t.set(5, "a")` | 空の木にノードを追加できる。 |
| 1-2 | ルートへの操作 | 値を更新 | `t = AVLTree(); t.set(5, "old")` | `t.set(5, "new")` | ルートを更新できる。 |
| 2-1 | 左への操作 | 挿入 | `t = AVLTree(); t.set(10, "a")` | `t.set(5, "b")` | ルートの左にノードを挿入できる。 |
| 2-2 | 左への操作 | 値を更新 | `t = AVLTree(); t.set(10, "a"); set(5, "b")` | `set(5, "b_new")` | ルートの左のノードを更新できる。 |
| 3-1 | 左左への操作 | 挿入（再バランス不要） | `t = AVLTree(); t.set(50, "a"); t.set(30, "b"); t.set(70, "c"); t.set(60, "d")` | `t.set(20, "f")` | ルートの左左にノードを挿入できる。再バランスされない。 |
| 3-2 | 左左への操作 | 挿入（再バランス発生） | `t = AVLTree(); t.set(10, "a"); t.set(5, "b")` | `t.set(3, "c")` | ルートの左左にノードを挿入した結果、再バランスが発生する。 |
| 3-3 | 左左への操作 | 値を更新 | `t = AVLTree(); t.set(50, "a"); t.set(30, "b"); t.set(70, "c"); t.set(60, "d"); t.set(20, "d")` | `t.set(20, "d_new")` | ルートの左左のノードを更新できる。 |
| 4-1 | 左右への操作 | 挿入（再バランス不要） | `t = AVLTree(); t.set(20, "a"); t.set(10, "b")` | `set(30, "c")` | ルートの左右にノードを挿入できる。再バランスされない。 |
| 4-2 | 左右への操作 | 挿入（再バランス発生） | `t = AVLTree(); t.set(10, "a"); t.set(3, "b")` | `t.set(5, "c")` | ルートの左右にノードを挿入した結果、再バランスが発生する。 |
| 4-3 | 左右への操作 | 値を更新 | `t = AVLTree(); t.set(20, "a"); t.set(10, "b"); t.set(30, "c")` | `t.set(30, "c_new")` | ルートの左右のノードを更新できる。 |
| 5-1 | 右への操作 | 挿入 | `t = AVLTree(); t.set(10, "a")` | `t.set(15, "b")` | ルートの右にノードを挿入できる。 |
| 5-2 | 右への操作 | 値を更新 | `t = AVLTree(); t.set(10, "a"); t.set(15, "b")` | `t.set(15, "b_new")` | ルートの右のノードを更新できる。 |
| 6-1 | 右左への操作 | 挿入（再バランス不要） | `t = AVLTree(); t.set(20, "a"); t.set(10, "b"); t.set(40, "c")` | `t.set(35, "d")` | ルートの右左にノードを挿入できる。再バランスされない。 |
| 6-2 | 右左への操作 | 挿入（再バランス発生） | `t = AVLTree(); t.set(30, "a"); t.set(40, "b")` | `t.set(35, "c")` | ルートの右左にノードを挿入できる。再バランスされる。 |
| 6-3 | 右左への操作 | 値を更新 | `t = AVLTree(); t.set(10, "a"); t.set(30, "b"); t.set(20, "c")` | `set(20, "c_new")` | ルートの右左のノードを更新できる。 |
| 7-1 | 右右への操作 | 挿入（再バランス不要） | `t = AVLTree(); t.set(20, "a"); t.set(10, "b"); t.set(25, "c")` | `t.set(30, "d")` | ルートの右右にノードを挿入できる。再バランスされない。 |
| 7-2 | 右右への操作 | 挿入（再バランス発生） | `t = AVLTree(); t.set(30, "a"); t.set(40, "b")` | `t.set(50, "c")` | ルートの右右にノードを挿入できる。再バランスされる。 |
| 7-3 | 右右への操作 | 値を更新 | `t = AVLTree(); t.set(10, "a"); t.set(20, "b"); t.set(30, "c")` | `t.set(30, "c_new")` | ルートの右右のノードを更新できる。 |

## 3. `get(x: int, default=None) → Any`

| No. | テスト観点 | 前提条件 | テスト手順 | 期待結果 |
| --- | --- | --- | --- | --- | --- |
| 1-1 | ルートから取得（ルートに存在） | `t = AVLTree(); t.set(10, "a")` | `t.get(10)` | `"a"` |
| 1-2 | ルートから取得（ルートに非存在） | `t = AVLTree()` | `t.get(5)` | `None` |
| 2-1 | 左から取得（左側に存在） | `t = AVLTree(); t.set(10, "a"); t.set(5, "b")` | `t.get(5)` | `"b"` |
| 2-2 | 左から取得（左側に非存在） | `t = AVLTree(); t.set(10, "a"); t.set(5, "b")` | `t.get(3)` | `None` |
| 3-1 | 左→左から取得（左→左に存在） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(10, "d")` | `t.get(10)` | `"d"` |
| 3-2 | 左→左から取得（左→左に非存在） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(10, "d")` | `t.get(5)` | `None` |
| 4-1 | 左→右から取得（左→右に存在） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(10, "d"); t.set(30, "e")` | `t.get(30)` | `"e"` |
| 4-2 | 左→右から取得（左→右に非存在） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(10, "d"); t.set(30, "e")` | `t.get(15)` | `None` |
| 5-1 | 右から取得（右側に存在） | `t = AVLTree(); t.set(10, "a"); t.set(15, "b")` | `t.get(15)` | `"b"` |
| 5-2 | 右から取得（右側に非存在） | `t = AVLTree(); t.set(10, "a"); t.set(15, "b")` | `t.get(20)` | `None` |
| 6-1 | 右→左から取得（右→左に存在） | `t = AVLTree(); t.set(20, "a"); t.set(40, "b"); t.set(10, "c"); t.set(30, "d"); t.set(50, "e")` | `t.get(30)` | `"d"` |
| 6-2 | 右→左から取得（右→左に非存在） | `t = AVLTree(); t.set(20, "a"); t.set(40, "b"); t.set(10, "c"); t.set(30, "d"); t.set(50, "e")` | `t.get(25)` | `None` |
| 7-1 | 右→右から取得（右→右に存在） | `t = AVLTree(); t.set(20, "a"); t.set(10, "b"); t.set(30, "c"); t.set(40, "d")` | `t.get(40)` | `"d"` |
| 7-2 | 右→右から取得（右→右に非存在） | `t = AVLTree(); t.set(20, "a"); t.set(10, "b"); t.set(30, "c"); t.set(40, "d")` | `t.get(35)` | `None` |
| 8-1 | デフォルト値の指定（なし） | `t = AVLTree()` | `t.get(5)` | `None` |
| 8-2 | デフォルト値の指定（あり） | `t = AVLTree()` | `t.get(5, "default")` | `"default"` |

## 4. `find(x: int) → bool`

| No. | テスト観点 | 前提条件 | テスト手順 | 期待結果 |
| --- | --- | --- | --- | --- | --- |
| 1-1 | ルートを判定（ルートに存在） | `t = AVLTree(); t.set(10, "a")` | `t.find(10)` | `True` を返す |
| 1-2 | ルートを判定（ルートに非存在） | `t = AVLTree()` | `t.find(5)` | `False` を返す |
| 2-1 | 左を判定（左側に存在） | `t = AVLTree(); t.set(10, "a"); t.set(5, "b")` | `t.find(5)` | `True` を返す |
| 2-2 | 左を判定（左側に非存在） | `t = AVLTree(); t.set(10, "a"); t.set(5, "b")` | `t.find(3)` | `False` を返す |
| 3-1 | 左→左を判定（左→左に存在） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(10, "d")` | `t.find(10)` | `True` を返す |
| 3-2 | 左→左を判定（左→左に非存在） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(10, "d")` | `t.find(5)` | `False` を返す |
| 4-1 | 左→右を判定（左→右に存在） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(10, "d"); t.set(30, "e")` | `t.find(30)` | `True` を返す |
| 4-2 | 左→右を判定（左→右に非存在） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(10, "d"); t.set(30, "e")` | `t.find(15)` | `False` を返す |
| 5-1 | 右を判定（右側に存在） | `t = AVLTree(); t.set(10, "a"); t.set(15, "b")` | `t.find(15)` | `True` を返す |
| 5-2 | 右を判定（右側に非存在） | `t = AVLTree(); t.set(10, "a"); t.set(15, "b")` | `t.find(20)` | `False` を返す |
| 6-1 | 右→左を判定（右→左に存在） | `t = AVLTree(); t.set(20, "a"); t.set(40, "b"); t.set(10, "c"); t.set(30, "d"); t.set(50, "e")` | `t.find(30)` | `True` を返す |
| 6-2 | 右→左を判定（右→左に非存在） | `t = AVLTree(); t.set(20, "a"); t.set(40, "b"); t.set(10, "c"); t.set(30, "d"); t.set(50, "e")` | `t.find(25)` | `False` を返す |
| 7-1 | 右→右を判定（右→右に存在） | `t = AVLTree(); t.set(20, "a"); t.set(10, "b"); t.set(30, "c"); t.set(40, "d")` | `t.find(40)` | `True` を返す |
| 7-2 | 右→右を判定（右→右に非存在） | `t = AVLTree(); t.set(20, "a"); t.set(10, "b"); t.set(30, "c"); t.set(40, "d")` | `t.find(35)` | `False` を返す |

## 5. `delete(x: int) → AVLTree`

| No. | テスト観点 | 前提条件 | テスト手順 | 期待結果 |
| --- | --- | --- | --- | --- | --- |
| 1-1 | ルートから削除（削除・再バランス不要） | `t = AVLTree(); t.set(10, "a"); t.set(5, "b")` | `t.delete(10)` | 再バランスは発生せず `items() == [(5, "b")]` となる。 |
| 1-2 | ルートから削除（削除・再バランス発生） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(10, "d"); t.set(5, "e")` | `t.delete(60)` | 削除後に再バランスが発生し、バランスが保たれる。 |
| 1-3 | ルートから削除（削除対象が存在しない） | `t = AVLTree()` | `t.delete(5)` | `items()` が変わらない。 |
| 1-4 | ルートから削除（ルートが葉の場合） | `t = AVLTree(); t.set(5, "a")` | `t.delete(5)` | 木が空になり `items() == []`となる。 |
| 2-1 | 左から削除（削除・再バランス不要） | `t = AVLTree(); t.set(30, "a"); t.set(10, "b"); t.set(40, "c")` | `t.delete(10)` | 再バランスは発生せず `items()` に `10` が含まれない。 |
| 2-2 | 左から削除（削除・再バランス発生） | `t = AVLTree(); t.set(50, "a"); t.set(30, "b"); t.set(70, "c"); t.set(20, "d"); t.set(10, "e")` | `t.delete(70)` | 削除後に再バランスが発生し、バランスが保たれる。 |
| 2-3 | 左から削除（削除対象が存在しない） | `t = AVLTree(); t.set(30, "a"); t.set(10, "b")` | `t.delete(5)` | `items()` が変わらない。 |
| 2-4 | 左から削除（葉以外のノード削除） | `t = AVLTree(); t.set(50, "a"); t.set(30, "b"); t.set(20, "c"); t.set(40, "d")` | `t.delete(30)` | 該当ノードが削除され `items()` が更新される。 |
| 3-1 | 左→左から削除（削除・再バランス不要） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(10, "d")` | `t.delete(10)` | 再バランスは発生せず `items()` に `10` が含まれない。 |
| 3-2 | 左→左から削除（削除・再バランス発生） | `t = AVLTree(); t.set(60, "a"); t.set(40, "b"); t.set(80, "c"); t.set(30, "d"); t.set(20, "e")` | `t.delete(80)` | 削除後に再バランスが発生し、バランスが保たれる。 |
| 3-3 | 左→左から削除（削除対象が存在しない） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b")` | `t.delete(5)` | `items()` が変わらない。 |
| 4-1 | 左→右から削除（削除・再バランス不要） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(10, "d"); t.set(30, "e")` | `t.delete(30)` | 再バランスは発生せず `items()` に `30` が含まれない。 |
| 4-2 | 左→右から削除（削除・再バランス発生） | `t = AVLTree(); t.set(50, "a"); t.set(30, "b"); t.set(70, "c"); t.set(20, "d"); t.set(10, "e"); t.set(25, "f")` | `t.delete(70)` | 削除後に再バランスが発生しバランスが保たれる。 |
| 4-3 | 左→右から削除（削除対象が存在しない） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c")` | `t.delete(15)` | `items()` が変わらない。 |
| 5-1 | 右から削除（削除・再バランス不要） | `t = AVLTree(); t.set(10, "a"); t.set(15, "b")` | `t.delete(15)` | 再バランスは発生せず `items() == [(10, "a")]` となる。 |
| 5-2 | 右から削除（削除・再バランス発生） | `t = AVLTree(); t.set(20, "a"); t.set(10, "b"); t.set(30, "c"); t.set(40, "d"); t.set(50, "e")` | `t.delete(10)` | 削除後に再バランスが発生し、バランスが保たれる。 |
| 5-3 | 右から削除（削除対象が存在しない） | `t = AVLTree(); t.set(10, "a"); t.set(15, "b")` | `t.delete(20)` | `items()` が変わらない。 |
| 5-4 | 右から削除（右側ノード削除） | `t = AVLTree(); t.set(40, "a"); t.set(20, "b"); t.set(60, "c"); t.set(50, "d")` | `t.delete(50)` | 該当ノードが削除され `items()` が更新される。 |
| 6-1 | 右→左から削除（削除・再バランス不要） | `t = AVLTree(); t.set(20, "a"); t.set(40, "b"); t.set(10, "c"); t.set(30, "d"); t.set(50, "e")` | `t.delete(30)` | 再バランスは発生せず `items()` に `30` が含まれない。 |
| 6-2 | 右→左から削除（削除・再バランス発生） | `t = AVLTree(); t.set(30, "a"); t.set(10, "b"); t.set(50, "c"); t.set(5, "d"); t.set(15, "e"); t.set(12, "f")` | `t.delete(5)` | 削除後に再バランスが発生しバランスが保たれる。 |
| 6-3 | 右→左から削除（削除対象が存在しない） | `t = AVLTree(); t.set(20, "a"); t.set(40, "b"); t.set(10, "c")` | `t.delete(25)` | `items()` が変わらない。 |
| 7-1 | 右→右から削除（削除・再バランス不要） | `t = AVLTree(); t.set(20, "a"); t.set(10, "b"); t.set(30, "c"); t.set(40, "d")` | `t.delete(40)` | 再バランスは発生せず `items()` に `40` が含まれない。 |
| 7-2 | 右→右から削除（削除・再バランス発生） | `t = AVLTree(); t.set(10, "a"); t.set(20, "b"); t.set(30, "c"); t.set(40, "d"); t.set(50, "e")` | `t.delete(20)` | 削除後に再バランスが発生し、バランスが保たれる。 |
| 7-3 | 右→右から削除（削除対象が存在しない） | `t = AVLTree(); t.set(20, "a"); t.set(10, "b"); t.set(30, "c")` | `t.delete(35)` | `items()` が変わらない。 |
| 8-1 | 2子ノード削除（後継が葉） | `t = AVLTree(); t.set(30, "a"); t.set(10, "b"); t.set(50, "c"); t.set(5, "d"); t.set(20, "e"); t.set(40, "f"); t.set(60, "g")` | `t.delete(30)` | `items()` に `30` がなく、`40` が置換されている（ソート順保たれる）、再バランスは発生しない。 |
| 8-2 | 2子ノード削除（後継に右子がある） | `t = AVLTree(); t.set(30, "a"); t.set(20, "b"); t.set(40, "c"); t.set(35, "d"); t.set(37, "e"); t.set(50, "f")` | `t.delete(30)` | `items()` に `30` がなく、`35` が置換されている／`37` が適切に移動している（ソート順保たれる）。 |
| 8-3 | 2子ノード削除（置換後に再バランス発生） | `t = AVLTree(); t.set(50, "a"); t.set(30, "b"); t.set(70, "c"); t.set(20, "d"); t.set(40, "e"); t.set(60, "f"); t.set(80, "g"); t.set(10, "h"); t.set(5, "i"); t.set(25, "j"); t.set(35, "k"); t.set(45, "l")` | `t.delete(30)` | `items()` に `30` がなく、後継で置換された後に再バランスが発生し、AVL 条件が保たれる。 |

## 6. `items() → list[tuple[int, Any]]`

| No. | テスト観点 | 前提条件 | テスト手順 | 期待結果 |
| --- | --- | --- | --- | --- | --- |
| 1-1 | ノード数：0（空の木） | `t = AVLTree()` | `t.items()` | `[]` |
| 2-1 | ノード数：1（1つのノード） | `t = AVLTree(); t.set(5, "a")` | `t.items()` | `[(5, "a")]` |
| 3-1 | ノード数：2（昇順で挿入） | `t = AVLTree(); t.set(1, "a"); t.set(2, "b")` | `t.items()` | `[(1, "a"), (2, "b")]` |
| 3-2 | ノード数：2（降順で挿入） | `t = AVLTree(); t.set(2, "a"); t.set(1, "b")` | `t.items()` | `[(1, "b"), (2, "a")]` |
| 4-1 | ノード数：3（昇順で挿入） | `t = AVLTree(); t.set(1, "a"); t.set(2, "b"); t.set(3, "c")` | `t.items()` | `[(1, "a"), (2, "b"), (3, "c")]` |
| 4-2 | ノード数：3（降順で挿入） | `t = AVLTree(); t.set(3, "a"); t.set(2, "b"); t.set(1, "c")` | `t.items()` | `[(1, "c"), (2, "b"), (3, "a")]` |
| 4-3 | ノード数：3（混合順で挿入） | `t = AVLTree(); t.set(2, "a"); t.set(1, "b"); t.set(3, "c")` | `t.items()` | `[(1, "b"), (2, "a"), (3, "c")]` |
